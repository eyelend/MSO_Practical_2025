1.

  classDiagram
    %%region Application
        namespace namespace_Applic{
            class Application{
                +void Run()
                #Program AskForProgram()
                #void UseProgram()
            }
            class ProgramImporter{
                -string path 
                -Program parse(String code)
                +Program importFromtxt(string relativePath)
            }
            class ExamplePrograms{
                +Program basic1
                +Program basic2
                +Program advanced1
                +Program expert1
                ...
            }
        }
        Application *-- ProgramImporter
        ProgramImporter ..> Program : creates
        Application *-- ExamplePrograms
        ExamplePrograms --> Program
        ProgramMetrics <.. Application : uses
    %%

    ProgramImporter ..> Body.Builder : creates
    ExamplePrograms ..> Body.Builder : creates

    %%region Commands
        namespace namesapce_Commands{
            class ProgramMetrics{
                +int commandCount
                +int maxNestingLevel
                +int repeatCommandCount
            }
            class Body.Builder{
                +Body.Builder turn(Dir2 dir)
                +Body.Builder move(int stepCount)
                +Body.Builder repeat(int count, Body.Builder body)
                +Body build()
            }
            class ICommand{
                +void ApplyOnWorld(ref World world)
                +ProgramMetrics getMetrics()
            }
            class Body
            class Repeat{
                +int count
            }
            class Turn{
                +Dir2 dir
            }
            class Move{
                +int stepCount
            }
        }
        <<interface>> ICommand
        ProgramMetrics <.. ICommand : creates
        Body <-- Repeat : 1 body
        Body.Builder ..> Body : creates
        Body.Builder --> ICommand : * commands
        Body.Builder ..> Repeat : creates
        Body.Builder ..> Turn : creates
        Body.Builder ..> Move : creates
        Body ..|> ICommand
        Body --> ICommand : * commands
        ICommand <|.. Turn
        ICommand <|.. Move
        Repeat ..|> ICommand
    %%

    ICommand ..> World : affects

    class Program{
        +WorldState execute()
    }
    Program --> Body : 1 commands
    Program --> World : 1 startWorld
    %%ProgramMetrics <.. Program


    %%region World
        namespace namespace_World{
            class World{
                +World Copy()
                +void TurnLeft()
                +void TurnRight()
                +void MoveForward(int dist)
            }
            class WorldSettings{
                %% Data that can't change while the program is running
            }
            class WorldState{
                %% Data that can be changed by the program
                +void AddToTrace(IEventTrace event)
            }
            class PlayerState{
                +int2 pos
                +Dir4 dir
            }
            class IEventTrace{
                +string TextualTrace()
            }
            class TurnTrace{
                +Dir2 dir
            }
            class MoveTrace{
                +int stepCount
            }
        }
        <<interface>> IEventTrace
        World --> WorldState : 1 startState
        World *-- WorldSettings
        WorldState *-- PlayerState : 1 player
        WorldState *-- IEventTrace : * trace
        WorldState ..> IEventTrace : creates
        IEventTrace <|.. TurnTrace
        IEventTrace <|.. MoveTrace
    %%

    Program ..> WorldState

    %%region Geometry2D
        namespace namespace_Geometry2D{
            class Dir4{
                +Dir4 North $
                +Dir4 East $
                +Dir4 South $
                +Dir4 West $

                +int2 ToVector()*
                +Dir4 Rotate(Dir2 dir)*
                int2 MovePoint(int2 point, int dist)
            }
        }
        PlayerState <-- Dir4
    %%







Design patterns:
  - We use the 'chain of responsibility'-pattern to pass commands through the world-classes to the player.

  - Body uses the builder-pattern so classes can create Program-instances without needing to create all ICommand-instances themselves. This leads to looser coupling.

  - Dir4 uses the state- and singleton-patterns, because there are only 4 directions. We'll never need a fifth.

2.
  Likely future changes:
    - A new type of command gets added, for example ...
    - Walls get added to the world. These can be stored in the class WorldSettings, because the program doesn't affect the walls. World's MoveForward-method must be adapted so that it lets walls block player movement.
    - We might want to be able to import programs from different formats. We could do that by making ProgramImporter abstract and creating different types of ProgramImporter, one for each format.

  High cohesion:
    - We introduced interface IEventTrace where we could have reused ICommand. Now not every type of command needs to be traceable. 
    - We separated WorldState and WorldSettings, to remind the programmers which features of the world can be changed by a program and which can't.
    - We introduced classes ProgramImporter and ExamplePrograms, because the code would have been more messy if we put all that data in the Application-class.

  Low coupling:
    - We introduced interface IEventTrace where we could have reused ICommand and connected them only through World, so the world-classes could depend less on ICommand.
    ...


4.
  ...






