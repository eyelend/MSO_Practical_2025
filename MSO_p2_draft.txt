1.

  classDiagram
    %%region Application
        namespace namespace_Applic{
            class Application{
                +void Run()
                #Program AskForProgram()
                #void UseProgram()
            }
            class ProgramImporter{
                -string path 
                -Program parse(String code)
                +Program importFromtxt(string relativePath)
            }
            class ExamplePrograms{
                +Program basic1
                +Program basic2
                +Program advanced1
                +Program expert1
                ...
            }
        }
        Application *-- ProgramImporter
        ProgramImporter ..> Program : creates
        Application *-- ExamplePrograms
        ExamplePrograms --> Program
        Application ..> ProgramMetrics : uses
    %%

    ProgramImporter ..> ICommand : creates
    ExamplePrograms ..> ICommand : creates

    %%region Commands
        namespace namesapce_Commands{
            class ICommand{
                +void ApplyOnWorld(ref World world)
            }
            class Repeat{
                +int count
            }
            class Turn{
                +Dir2 dir
            }
            class Move{
                +int stepCount
            }
        }
        <<interface>> ICommand
        ICommand <|.. Turn
        ICommand <|.. Move
        ICommand <|.. Repeat
        ICommand <-- Repeat : * body
    %%

    class Program{
        +WorldState execute()
    }
    Program --> ICommand : * commands
    Program --> World : 1 startWorld
    Program ..> WorldState
    ProgramMetrics <.. Program : creates
    class ProgramMetrics{
        +int commandCount
        +int maxNestingLevel
        +int repeatCommandCount
    }


    %%region World
        namespace namespace_World{
            class WorldState{
                %% Data that can be changed by the program
                +void AddToTrace(IEventTrace event)
            }
            class PlayerState{
                +int2 pos
                +Dir4 dir
            }
            class World{
                +World Copy()
                +void TurnLeft()
                +void TurnRight()
                +void MoveForward(int dist)
            }
            class WorldSettings{
                %% Data that can't change while the program is running
            }
            class IEventTrace{
                +string TextualTrace()
            }
            class TurnTrace{
                +Dir2 dir
            }
            class MoveTrace{
                +int stepCount
            }
        }
        <<interface>> IEventTrace
        WorldState *-- PlayerState : 1 player
        WorldState *-- IEventTrace : * trace
        World --> WorldState : 1 startState
        WorldState ..> IEventTrace : creates
        World *-- WorldSettings
        IEventTrace <|.. TurnTrace
        IEventTrace <|.. MoveTrace
    %%

    ICommand ..> World : affects




Design patterns:
  - We use the 'chain of responsibility'-pattern to pass commands through the world-classes to the player.

Todo: Try to use the builder-pattern on Program so the classes that create Program-instances don't need to depend on ICommand and its children.

Todo: Put Dir4 in the uml, showing how it uses the state- and singleton-patterns.

2.
  Likely future changes:
    - A new type of command gets added, for example ...
    - Walls get added to the world. These can be stored in the class WorldSettings, because the program doesn't affect the walls. World's MoveForward-method must be adapted so that it lets walls block player movement.
    - We might want to be able to import programs from different formats. We could do that by making ProgramImporter abstract and creating different types of ProgramImporter, one for each format.

  High cohesion:
    - We introduced interface IEventTrace where we could have reused ICommand. Now not every type of command needs to be traceable. 
    - We separated WorldState and WorldSettings, to remind the programmers which features of the world can be changed by a program and which can't.
    - We introduced classes ProgramImporter and ExamplePrograms, because the code would have been more messy if we put all that data in the Application-class.

  Low coupling:
    - We introduced interface IEventTrace where we could have reused ICommand and connected them only through World, so the world-classes could depend less on ICommand.
    ...


4.
  ...






